-- parseit.lua                                                                -
-- Tristan Van Cise                                                           -
-- 03/02/2018                                                                 -
-- Programming Languages                                                      -
-- Assignment 4 - Exercise A                                                  -
--                                                                            -
-- Contains parseit module function definitions for dugong language parsing.  -
-- The main concern of this program is interpretting keywords and parameters  -
-- together to construct an abstract syntax tree (AST) for the given program. -
-- This is done via a recursive descent parsing algorithm, which expands      -
-- non-terminal lexemes until a terminal state is met. Internally, the ASTs   -
-- and recursive descent data structure is implemented with a table.          -
-------------------------------------------------------------------------------

local parseit = {}

lexit = require "lexit"

-- Parseit member variables
-- These keep track of current lexeme in program string

local iter
local state
local lexit_out_s
local lexit_out_c

local lexstr = ""
local lexcat = 0

-- Category constants used for parseit output

STMT_LIST   = 1
INPUT_STMT  = 2
PRINT_STMT  = 3
FUNC_STMT   = 4
CALL_FUNC   = 5
IF_STMT     = 6
WHILE_STMT  = 7
ASSN_STMT   = 8
CR_OUT      = 9
STRLIT_OUT  = 10
BIN_OP      = 11
UN_OP       = 12
NUMLIT_VAL  = 13
BOOLLIT_VAL = 14
SIMPLE_VAR  = 15
ARRAY_VAR   = 16


-- Utility Functions --

-- Most functions here rely on init being called first before they
-- can properly carry out their tasks

-- Name: advance
--
-- Description: update lexstr and lexcat to advance
-- to the next lexeme. If preferOp conditions are met,
-- the lexer preferOp flag is set (see first if statement
-- below) which makes '+' or '-' ops rather than numlits
-- 
local function advance()
  if lexcat == lexit.ID or lexcat == lexit.NUMLIT
     or lexstr == "]" or lexstr == ")"
     or lexstr == "true" or lexstr == "false" then
       lexit.preferOp()
  end
  
  lexit_out_s, lexit_out_c = iter(state, lexit_out_c)
  
  if lexit_out_s ~= nil then
    lexstr, lexcat = lexit_out_s, lexit_out_c
  else
    lexstr, lexcat = "", 0
  end
end


-- Name: init
--
-- Description: Sets up input for parse functions
-- 
local function init(prog)
  iter, state, lexit_out_s = lexit.lex(prog)
  advance()
end


-- Name: atEnd
--
-- Description: Returns boolean indicating end of program
-- 
local function atEnd()
  return lexcat == 0
end


-- Name: matchString
--
-- Description: Returns a boolean dictating whether the parameter
-- string matches the current lexeme. If true, advance is also called
-- and the current lexeme is advanced by one in the program. 
-- 
local function matchString(compareString)
  if lexstr == compareString then
    advance()
    return true
  else
    return false
  end
end


-- Name: matchCat
--
-- Description: Returns a boolean dictating whether the parameter
-- category matches the current lexeme category. If true, advance 
-- is also called and the current lexeme is advanced by one in 
-- the program.
-- 
local function matchCat(compareCategory)
  if lexcat == compareCategory then
    advance()
    return true
  else
    return false
  end
end


-- Name: parseit.parse
--
-- Description: Exported parse function called by client to
-- initiate parse functions on given program string.
--
-- good indicates the parser's failure or success parsing the program
-- ast is the abstract syntax tree generated by the parser
-- done indicates if the end of program string was reached
--
function parseit.parse(prog)
  init(prog)
  
  local good, ast = parse_stmt_list()
  local done = atEnd()
  
  return good, done, ast
end


-- Parse Functions --


-- Name: parse_stmt_list
--
-- Description: Checks for keywords the require additional parsing.
-- If a keyword is found, the AST is further modified by other parse
-- functions, otherwise, the { STMT_LIST } AST is returned.
-- 
function parse_stmt_list()
    local good, ast, newast
    ast = { STMT_LIST }
    while true do
          if  lexstr ~= "input"
          and lexstr ~= "print"
          and lexstr ~= "func"
          and lexstr ~= "call"
          and lexstr ~= "if"
          and lexstr ~= "while"
          and lexcat ~= lexit.ID then
            return true, ast
        end
        good, newast = parse_statement()
        if not good then
            return false, nil
        end
        table.insert(ast, newast)
    end
end


-- Name: parse_statement
--
-- Description: Handles all keyword statements and acts as a central hub
-- for branching to other parser functions. Depending on the keyword,
-- different parsing methods and parsing functions are called to generate
-- an AST.
-- 
-- input: returns AST from parse_lvalue
--
-- print: returns AST from print_arg and continues to add print_arg ASTs
--        so long as each new argument is separated by a ';'
--
-- func:  returns AST from parse_stmt_list so long as the keywords is 
--        followed by and ID and ends with the lexeme 'end'
--
-- call:  returns an AST containing the function's ID string
--
-- if:    returns an AST containing ASTs generated from parse_expr and
--        parse_stmt_list. This process is continued with each successive
--        'elseif' lexeme, followed by an optional 'else' keyword, which adds
--        a final parse_stmt_list AST before returning as long as the lexeme
--        'end' is present immediately after. 
--
-- while: returns an AST assembled from parse_expr and parse_stmt_list so long
--        as the terminal lexeme 'end' is present at the end.
--
-- assignment: returns an AST derived from parse_lvalue and parse_expr if an 
--        '=' separates the two expressions. 
--
function parse_statement()
    local good, ast1, ast2, savelex
    if matchString("input") then
        good, ast1 = parse_lvalue()
        if not good then
            return false, nil
        end
        return true, { INPUT_STMT, ast1 }
    elseif matchString("print") then
        good, ast1 = parse_print_arg()
        if not good then
            return false, nil
        end
        ast2 = { PRINT_STMT, ast1 }
        while true do
            if not matchString(";") then
                break
            end
            good, ast1 = parse_print_arg()
            if not good then
                return false, nil
            end
            table.insert(ast2, ast1)
        end
        return true, ast2
    elseif matchString("call") then
      savelex = lexstr
      if matchCat(lexit.ID) then
        return true, { CALL_FUNC, savelex }
      end
      return false, nil
    elseif matchString("func") then
      savelex = lexstr
      
      if matchCat(lexit.ID) then
        good, ast1 = parse_stmt_list()
        if not good then 
          return false, nil
        end
        if matchString("end") then
          return true, {FUNC_STMT, savelex, ast1}
        end
        return false,nil
      end
    elseif matchString("while") then
      good, ast1 = parse_expr()
      if not good then
        return false, nil
      end
      
      good, ast2 = parse_stmt_list()
      if not good then
        return false, nil
      end
      
      if matchString("end") then
        return true, { WHILE_STMT, ast1, ast2 }
      end
      
      return false, nil
    elseif matchString("if") then
      
      good, ast1 = parse_expr()
      if not good then
        return false, nil
      end
      ast2 = {IF_STMT, ast1}
      
      good, ast1 = parse_stmt_list()
      if not good then
        return false, nil
      end
      table.insert(ast2, ast1)
      
      while true do
        saveop = lexstr
        if not matchString("elseif") then
            break
        end

        good, ast1 = parse_expr()
        if not good then
          return false, nil
        end
        table.insert(ast2, ast1)
        
        good, ast1 = parse_stmt_list()
        if not good then
          return false, nil
        end
        table.insert(ast2, ast1)
        
      end
      
      if matchString("else") then
        good, ast1 = parse_stmt_list()
        if not good then
          return false, nil
        end
        table.insert(ast2, ast1)
      end
      
      if matchString("end") then
        return true, ast2
      end
      
      return false, nil
    else
      good, ast1 = parse_lvalue()
      if not good then
        return false, nil
      end
      
      if matchString("=") then
        good, ast2 = parse_expr()
        if not good then
          return false, nil
        end
        return true, { ASSN_STMT, ast1, ast2 }
      end
      
      return false, nil
    end
end


-- Name: parse_print_arg
--
-- Description: A print argument consists of three possible criteria:
-- 
-- 1) "cr" immediately returns an AST with CR_OUT category
-- 2) String literals return an AST with STRLIT_OUT category and the string literal
-- 3) An expression, which is handled by parse_expr()
-- 
function parse_print_arg()
  local savelex
  
  savelex = lexstr
  if matchString("cr") then
    return true, { CR_OUT }
  elseif matchCat(lexit.STRLIT) then
    return true, { STRLIT_OUT, savelex }
  else
    return parse_expr()
  end
  
end


-- Name: parse_expr
--
-- Description: Handles "&&" and "||" operators.
-- Returns an AST composed of ASTs returned from parse_comp_expr.
-- Works with arbitrary amount of consecutive "&&" and "||" expressions.
-- 
-- NOTE:
-- parse_expr, parse_comp_expr, parse_arith_expr, and parse_term all have
-- identical behavior but handle different operations.
--
function parse_expr()
    local good, ast, saveop, newast

    good, ast = parse_comp_expr()
    if not good then
        return false, nil
    end

    while true do
        saveop = lexstr
        if not matchString("&&") and not matchString("||") then
            break
        end

        good, newast = parse_comp_expr()
        if not good then
            return false, nil
        end

        ast = { { BIN_OP, saveop }, ast, newast }
    end

    return true, ast
end


-- Name: parse_comp_expr
--
-- Description: Handles comparison operator parsing. Returns either
-- an AST with the unary operator "!" and UN_OP category or a binary
-- comparison operator with the BIN_OP category. Works for an arbitrary
-- amount of consecutive operator. 
-- 
function parse_comp_expr()
  local good, ast, saveop, newast
  
    if matchString("!") then
      good, ast = parse_comp_expr()
      
      if not good then
        return false, nil
      end
      
      return true, { {UN_OP, "!"}, ast }
    end
  
    good, ast = parse_arith_expr()
    if not good then
        return false, nil
    end

    while true do
        saveop = lexstr
        if not matchString("==") and not matchString("!=") 
            and not matchString("<") and not matchString("<=")
            and not matchString(">") and not matchString(">=") then
            break
        end

        good, newast = parse_arith_expr()
        if not good then
            return false, nil
        end

        ast = { { BIN_OP, saveop }, ast, newast }
    end

    return true, ast
end


-- Name: parse_arith_expr
--
-- Description: Handles '+' and '-' arithmetic operators.
-- Returns an AST composed of ASTs returned from parse_term.
-- Works with arbitrary amount of consecutive arithmetic
-- expression.
-- 
function parse_arith_expr()
  local good, ast, saveop, newast
  
  good, ast = parse_term()
    if not good then
        return false, nil
    end

    while true do
        saveop = lexstr
        if not matchString("+") and not matchString("-") then
            break
        end

        good, newast = parse_term()
        if not good then
            return false, nil
        end

        ast = { { BIN_OP, saveop }, ast, newast }
    end

    return true, ast
end


-- Name: parse_term
--
-- Description: Handles '*', '/', and '%' terms.
-- Returns an AST composed of ASTs returned from parse_factor.
-- Works with arbitrary amount of consecutive term expressions.
-- 
function parse_term()
    local good, ast, saveop, newast

    good, ast = parse_factor()
    if not good then
        return false, nil
    end

    while true do
        saveop = lexstr
        if not matchString("*") and not matchString("/") 
            and not matchString("%") then
            break
        end

        good, newast = parse_factor()
        if not good then
            return false, nil
        end

        ast = { { BIN_OP, saveop }, ast, newast }
    end

    return true, ast
end


-- Name: parse_factor
--
-- Description: Constructs basic ASTs for entities categorized as unary operators (+ or -),
-- call function IDs, numeric literals, boolean literals, idividual IDs, and expressions
-- contained within parenthesis. Respective categories UN_OP, CALL_FUNC, NUMLIT_VAL, and
-- BOOLLIT_VAL are used in AST returns, while IDs and parenthesis contained expressions are
-- handled by parse_lvalue and parse_expr.
-- 
function parse_factor()
    local savelex, good, ast

    savelex = lexstr
    if matchString("+") or matchString("-") then
        good, ast = parse_factor()
        if not good then
          return false, nil
        end
        return true, { { UN_OP, savelex } , ast }
    elseif matchString("call") then
       savelex = lexstr
       if matchCat(lexit.ID) then
         return true, { CALL_FUNC, savelex }
       end
      return false, nil
    elseif matchCat(lexit.NUMLIT) then
        return true, { NUMLIT_VAL, savelex }
    elseif matchString("true") or matchString("false") then
        return true, { BOOLLIT_VAL, savelex }
    elseif lexcat == lexit.ID then
        return parse_lvalue()
    elseif matchString("(") then
        good, ast = parse_expr()
        if not good then
            return false, nil
        end

        if not matchString(")") then
            return false, nil
        end

        return true, ast
    else
        return false, nil
    end
end


-- Name: parse_lvalue
--
-- Description: Returns SIMPLE_VAR AST for simple string identifiers or
-- ARRAY_VAR AST for strings with square brackets present
-- 
function parse_lvalue()
   local saveID
    
    saveID = lexstr
    if matchCat(lexit.ID) then
      if matchString("[") then
        good, ast = parse_expr()
        if not good then
            return false, nil
        end

        if not matchString("]") then
            return false, nil
        end
        
        return true, { ARRAY_VAR, saveID, ast }
      end
      
      return true, { SIMPLE_VAR, saveID }
    end
    
    return false, nil
end

return parseit